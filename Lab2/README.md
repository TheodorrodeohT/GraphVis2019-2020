# Визуализация данных [imdb.com](http://imdb.com "imdb.com")

Основным источником данных является датасет, собранный в [первой лабораторной работе](https://github.com/TheodorrodeohT/GraphVis2019-2020/edit/master/Lab1 "Lab1").

## Состав команды
Павлов Федор, Цхай Борис, Якушкин Николай.

## Этапы работы

Лабораторная работа поделена на три основных этапа: вначале составляются три графа, которые будут использоваться при дальнейшей визуализации, затем выполняется имплементация алгоритма spring-electrical layout model, а также реализация собственного алгоритма для визуализации графов, и в конце производится процесс визуализации.

Весь код доступен в jupyter-ноутбуке [GraphVisLab2.ipynb](https://github.com/TheodorrodeohT/GraphVis2019-2020/blob/master/Lab2/GraphVisLab2.ipynb "GraphVisLab2.ipynb").

### Графы

Для составления графов был использован датасет `imdb_dataset_filtered.csv`, из которого случайным образом было отобрано 10% элементов. Таким образом, получилось 1689 строк. Из него было составлено три основных графа:

* Граф 1: вершины - фильмы, ребро между вершинами означает, что эти фильмы имеют общего режиссёра. Граф строится с помощью функции `get_graph_t1(df)`, возвращающей номер графа, покраску вершин и покраску ребер. Цвет вершины зависит от параметра `titleType`. Ребра имеют одинаковый цвет.

* Граф 2: вершины - фильмы и режиссеры, ребро между вершинами означает прямое отношение между фильмом и режиссером. Граф строится с помощью функции `get_graph_t2(df)`, возвращающей номер графа, покраску вершин и покраску ребер. Цвет вершины принимает два значения, ребра имеют одинаковый цвет.

* Граф 3: вершины - фильмы, ребро между вершинами означает, что либо они имеют общего режиссера, либо сняты в один и тот же год. Граф строится с помощью функции `get_graph_t3(df)`, возвращающей номер графа, покраску вершин и покраску ребер. Все вершины имеют один цвет, но ребра либо оранжевые (один год), либо красные(один режиссёр).

### Алгоритмы (имплементированные)

Было имплементировано два алгоритма: force-directed алгоритм **spring-electrical** и алгоритм, который мы назвали **distances-layout**.

#### distances-layout

`distances_layout(G, distance=1, diameter=False)` визуализирует для случайной выбранной вершины каждой компоненты связности графа G, насколько далеко от неё находятся все остальные вершины данной компоненты. Сначала изображается выбранная вершина, потом справа на расстоянии distance от неё в столбец все вершины, соседние с ней, потом в следующем столбце справа на distance все вершины на расстоянии 2 от неё и т.д. Возвращает позиции для всех вершин графа G, а также возвращает метки для каждой вершины, обозначающие, насколько далеко в её компоненте данная вершина находится от случайно выбранной. Если `diameter` равен `True`, то выбирается не случайная вершина, а та, для которой наибольшое расстояние до другой вершины равно диаметру графа G. Для нахождения такой вершины приходится находить максимальное расстояние для каждой вершины, поэтому на очень больших графах нахождения координат для визуализации диаметра может занимать много времени.

Данный алгоритм выделяется тем, что по его визуализации можно явно увидеть количество компонент в графе и достаточно неплохо увидеть, как вершины соединены друг с другом. Также, если установить `diameter = True`, то можно увидеть, чему равен диаметр в каждой компоненте.

По многим опробованным алгоритмам, кроме **spring_layout** и других похожих, при достаточном количестве вершин и рёбер сложно понять, насколько граф связный. В них рёбра разных компонент связности пересекаются друг с другом, и может создатся ощущение, что есть только одна компонента. Приведённый алгоритм также по сравнению с некоторыми опробованными(например, **spring_layout** или **circular_layout**) для достаточно больших графов лучше показывает как вершины соединены друг с другом. Кроме того, если `diameter = True`, то по графику можно увидеть диаметр каждой компоненты, что может быть полезной информацией. При этом, данный алгоритм не очень хорошо подходит для визуализации графов с большим количеством компонент связности маленького размера.

Визуализация трёх графов выглядит следующим образом при `diameter=False` (изображения [кликабельны](https://github.com/TheodorrodeohT/GraphVis2019-2020/blob/master/Lab2/img "img")):

![distances_layout.png](https://github.com/TheodorrodeohT/GraphVis2019-2020/blob/master/Lab2/img/distances_layout.png)

А так при `diameter=True`:

![distances_layout_diameter.png](https://github.com/TheodorrodeohT/GraphVis2019-2020/blob/master/Lab2/img/distances_layout_diameter.png)


#### spring_electrical

В методе `spring_electrical(G, k, dim, step, tol, dec)` мы вводим две функции силы, действующие в разные стороны. Функция `Fa` применяется для каждой пары смежных вершин, функция `Fr` применяется для всех остальных. На каждом шаге мы двигаем каждую вершину по направлению ее силы, уменьшая шаг на каждой итерации. Этот цикл повторяется до тех пор, пока система расположения точек не стабилизируется. Одной из характерных особенностей модели **spring-electrical** является то, что вершины, находящиеся ближе к границе, располагаются ближе друг к другу, чем вершины в центре.

![spring_electrical.png](https://github.com/TheodorrodeohT/GraphVis2019-2020/blob/master/Lab2/img/spring_electrical.png)

### Алгоритмы (стандартные алгоритмы библиотеки networkx)

Для проверки изображений, полученных в результате работы наших алгоритмов, мы также построили каждый граф на нескольких методах из библиотеки **networkx**.

#### spring_layout

![spring_networkx.png](https://github.com/TheodorrodeohT/GraphVis2019-2020/blob/master/Lab2/img/spring_networkx.png)

#### kamada_kawai

![kamada_kawai_networkx.png](https://github.com/TheodorrodeohT/GraphVis2019-2020/blob/master/Lab2/img/kamada_kawai_networkx.png)
